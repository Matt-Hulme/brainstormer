---
description: 
globs: 
alwaysApply: true
---
# Frontend Development Guide

## Project Structure
Key directories and their purposes:
- @frontend/src/components - Reusable UI components
- @frontend/src/pages - Page components (routes)
- @frontend/src/utils - Utility functions
- @frontend/src/config - Configuration and API setup
- @frontend/src/hooks - Nested folders that contain commonly used hooks

## Component Guidelines
1. One component per file
2. Use PascalCase for component files
3. Keep components focused and single-responsibility
4. Use composition over inheritance
5. No index.ts files - use direct imports

## Component Organization
1. React hooks at the top of components, alphabetized by hook name:
   ```typescript
   // React hooks first, alphabetized
   const { data: collections } = useGetCollectionsQuery()
   const { data: project } = useGetProjectQuery()
   const { mutate: addWord } = useAddWordMutation()
   const { mutate: removeWord } = useRemoveWordMutation()
   ```

2. State hooks after React hooks, alphabetized by variable name:
   ```typescript
   // State hooks next, alphabetized
   const [activeWords, setActiveWords] = useState<string[]>([])
   const [selectedCollectionId, setSelectedCollectionId] = useState<string | null>(null)
   const [searchQuery, setSearchQuery] = useState('')
   ```

3. All custom functions after hooks, alphabetized by function name:
   - Event handlers (onClick, onChange, etc.)
   - Helper functions
   - Utility functions
   - Render functions
   ```typescript
   // Then all custom functions alphabetically
   const onAddItem = () => { ... }
   const onRemoveItem = () => { ... }
   const onUpdateItem = () => { ... }
   const formatData = () => { ... }
   const validateInput = () => { ... }
   ```

4. Use proper TypeScript types and interfaces
5. Follow import order:
   - React and external libraries
   - Types
   - Components
   - Hooks
   - Utils
   - Styles

## Event Handler Naming
1. Use `on` prefix for event handlers and props that handle events
2. Examples:
   ```typescript
   // Good
   const onSelectWord = () => { ... }
   const onRemoveWord = () => { ... }
   const onCollectionSelect = () => { ... }

   // Bad
   const handleSelectWord = () => { ... }
   const handleRemoveWord = () => { ... }
   const handleCollectionSelect = () => { ... }
   ```
3. This convention aligns with React's built-in event handlers (onClick, onChange, etc.)
4. Makes it clear that the function is an event handler
5. Maintains consistency across the codebase

## Type Organization
1. Keep types close to where they're used
2. Only move types to shared types directory if used in multiple places
3. Use descriptive type names
4. Export types from the same file they're defined in
5. Use interfaces for public APIs and types for internal use

## Defensive Programming
1. Always use optional chaining (`?.`) and nullish coalescing (`??`) operators when accessing potentially undefined or null values
2. Examples of good practices:
   ```typescript
   // Accessing nested properties
   const projectName = project?.name ?? 'Untitled Project'
   const collections = project?.collections?.map(c => c.name) ?? []

   // Function calls
   const result = obj?.method?.() ?? defaultValue

   // Array access
   const firstItem = array?.[0] ?? null
   ```
3. Avoid direct access without checks:
   ```typescript
   // Bad
   const projectName = project.name  // Could throw if project is undefined
   const collections = project.collections.map(c => c.name)  // Could throw

   // Bad - using || for null/undefined checks
   const value = obj.prop || defaultValue  // This will use defaultValue for falsy values like 0 or ''
   ```
4. Use cases for optional chaining and nullish coalescing:
   - Accessing nested object properties
   - Calling methods that might not exist
   - Accessing array elements
   - Dealing with API responses
   - Working with optional parameters
   - Handling user input
5. When not to use:
   - When you're certain a value exists
   - When you want to throw an error for missing values
   - When dealing with required parameters in function signatures

## Hook Organization
1. Keep hooks colocated with their related components/pages
2. Name query hooks with verb prefix and Query suffix (e.g., useGetProjectsQuery)
3. Name mutation hooks with verb prefix and Mutation suffix (e.g., useCreateProjectMutation)
4. Keep prefixes in the following format:
    - Get
    - Create
    - Update
    - Delete
4. Keep hooks focused and single-responsibility
5. Place hooks in the same directory as their related component/page

## Styling Rules
1. Use Tailwind CSS for styling
2. Follow mobile-first approach
3. Use CSS variables for theming
4. Avoid inline styles
5. Use classnames package for conditional classes

## API Integration
1. All API configuration in config directory
2. Use typed API responses
3. Handle errors consistently
4. Use environment variables for endpoints
5. Implement proper error handling

## Alphabetization Rules

1. **Props:** When passing props to a component (JSX or function), list them in alphabetical order.
   ```tsx
   // Good
   <Button
     className="btn-primary"
     disabled={isDisabled}
     onClick={onClick}
     type="submit"
   />
   
   // Bad
   <Button
     onClick={onClick}
     type="submit"
     className="btn-primary"
     disabled={isDisabled}
   />
   ```
2. **Variables and State:** Declare variables, state hooks, and function parameters in alphabetical order when possible.
   ```tsx
   // Good
   const [activeWords, setActiveWords] = useState<string[]>([])
   const [selectedCollectionId, setSelectedCollectionId] = useState<string | null>(null)
   
   // Good (function params)
   function doSomething(activeWords, projectName, selectedCollectionId) { ... }
   ```
3. **className Values:** When using multiple Tailwind or CSS classes, list them alphabetically for consistency.
   ```tsx
   // Good
   <div className="bg-white p-4 rounded shadow" />
   
   // Bad
   <div className="shadow rounded p-4 bg-white" />
   ```

**Benefits:**
- Improves code readability and maintainability
- Reduces merge conflicts
- Makes code reviews easier
