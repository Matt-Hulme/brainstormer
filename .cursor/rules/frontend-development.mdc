---
description: 
globs: 
alwaysApply: true
---
---
description: Frontend development rules including component organization, defensive programming, styling guidelines, conditional rendering, and export patterns
globs: ["frontend/src/**/*.{ts,tsx}"]
alwaysApply: true
---

# Frontend Development Guide

## Project Structure
Key directories and their purposes:
- @frontend/src/components - Reusable UI components
- @frontend/src/pages - Page components (routes)
- @frontend/src/utils - Utility functions
- @frontend/src/config - Configuration and API setup
- @frontend/src/hooks - Nested folders that contain commonly used hooks

## Component Guidelines
1. One component per file
2. Use PascalCase for component files
3. Keep components focused and single-responsibility
4. Use composition over inheritance
5. No index.ts files - use direct imports

## Component Organization
1. All imports should be alphabetically ordered, with no section comments
2. Component structure should follow this order, with alphabetical ordering within each section:
   - React hooks (useState, useEffect, etc.)
   - State hooks (useState, useReducer)
   - Custom functions (event handlers, helpers, etc.)
3. The above order and alphabetization can be broken only when necessary for variable scope
4. Example of proper organization:
   ```typescript
   import { useCallback, useEffect, useState } from 'react'
   import { useNavigate, useParams, useSearchParams } from 'react-router-dom'
   import { AlignLeft, GitBranch, Layers, Target } from 'lucide-react'
   import { Button } from '@/components/design-system/Button'
   import { HamburgerSidebar } from '@/components/HamburgerSidebar'
   import { SearchBar } from '@/components/SearchBar'
   import { useGetProjectQuery } from '@/hooks/projects/useGetProjectQuery'
   import { useSearchQuery } from '@/hooks/search/useSearchQuery'

   export const Search = () => {
     // React hooks (alphabetized)
     const navigate = useNavigate()
     const { projectName } = useParams<{ projectName: string }>()
     const [searchParams] = useSearchParams()

     // Variables needed for hooks (breaking order for scope)
     const searchValue = searchParams.get('q') ?? ''
     const searchMode = searchParams.get('mode') as 'or' | 'and' | 'both' ?? 'both'

     // React hooks (alphabetized)
     const { data, isLoading: searchLoading, error: searchError } = useSearchQuery(projectName ?? '', searchValue, searchMode)
     const { project, isLoading: projectLoading } = useGetProjectQuery(projectName ?? '')

     // State variables (alphabetized)
     const activeView = searchParams.get('view') ?? 'list'
     const hasAndMatches = data?.suggestions?.some(s => s.matchType === 'and') ?? false
     const hasMultiplePhrases = searchValue.includes('+')
     const hasOrMatches = data?.suggestions?.some(s => s.matchType === 'or') ?? false
     const isLoading = searchLoading || projectLoading

     // Custom functions (alphabetized)
     const onSearchModeChange = useCallback((mode: 'or' | 'and' | 'both') => {
       const newParams = new URLSearchParams(searchParams)
       newParams.set('mode', mode)
       navigate(`/projects/${projectName}/search?${newParams.toString()}`)
     }, [navigate, projectName, searchParams])

     return (
       // ...
     )
   }
   ```

5. Use proper TypeScript types and interfaces
6. Follow import order:
   - React and external libraries
   - Types
   - Components
   - Hooks
   - Utils
   - Styles

7. Variable Declaration Rules:
   - Variables must be declared before they are used
   - After declaration, related variables can be grouped together even if it breaks strict alphabetization and component section order.

   ```typescript
   // Variables declared before use
   const searchValue = searchParams.get('q') ?? ''
   const searchMode = searchParams.get('mode') as 'or' | 'and' | 'both' ?? 'both'
   
   // Related variables grouped together
   const { data, isLoading: searchLoading, error: searchError } = useSearchQuery(projectName ?? '', searchValue, searchMode)
   const hasMultiplePhrases = searchValue.includes('+')
   const hasAndMatches = data?.suggestions?.some(s => s.matchType === 'and') ?? false
   const hasOrMatches = data?.suggestions?.some(s => s.matchType === 'or') ?? false
   ```

8. When grouping related code, maintain alphabetical order within each group
9. Use descriptive variable names instead of comments to explain intent

## Comments
1. Only add comments for particularly complex logic, such as:
   - Complex useEffect dependencies or side effects
   - Non-obvious business logic
   - Complex state management patterns
   - Performance optimizations
2. DO NOT EVER ADD section comments like "React hooks", "State hooks", etc. If you see these, remove them.
3. DO NOT EVER add import comments like "External library imports". If you see these, remove them.
4. Use comments to explain "why" not "what" - the code should be self-documenting
4. Examples of good comments:
   ```typescript
   // This effect needs to run after the DOM is ready because it uses getBoundingClientRect
   useEffect(() => {
     // ...
   }, [])

   // We're using a workaround here because the API doesn't support batch updates
   const handleBatchUpdate = () => {
     // ...
   }
   ```
5. Examples of unnecessary comments:
   ```typescript
   // Bad - comment just repeats what the code says
   // Set the search value
   const searchValue = searchParams.get('q')

   // Bad - code is self-documenting
   // Function to add a new item
   const onAddItem = () => {
     // ...
   }
   ```

## Event Handler Naming
1. Use `on` prefix for event handlers and props that handle events
2. Examples:
   ```typescript
   // Good
   const onSelectWord = () => { ... }
   const onRemoveWord = () => { ... }
   const onCollectionSelect = () => { ... }

   // Bad
   const handleSelectWord = () => { ... }
   const handleRemoveWord = () => { ... }
   const handleCollectionSelect = () => { ... }
   ```
3. This convention aligns with React's built-in event handlers (onClick, onChange, etc.)
4. Makes it clear that the function is an event handler
5. Maintains consistency across the codebase

## Type Organization
1. Keep types close to where they're used
2. Only move types to shared types directory if used in multiple places
3. Use descriptive type names
4. Export types from the same file they're defined in
5. Use interfaces for public APIs and types for internal use

## Defensive Programming
1. Always use optional chaining (`?.`) and nullish coalescing (`??`) operators when accessing potentially undefined or null values
2. Examples of good practices:
   ```typescript
   // Accessing nested properties
   const projectName = project?.name ?? 'Untitled Project'
   const collections = project?.collections?.map(c => c.name) ?? []

   // Function calls
   const result = obj?.method?.() ?? defaultValue

   // Array access
   const firstItem = array?.[0] ?? null
   ```
3. Avoid direct access without checks:
   ```typescript
   // Bad
   const projectName = project.name  // Could throw if project is undefined
   const collections = project.collections.map(c => c.name)  // Could throw

   // Bad - using || for null/undefined checks
   const value = obj.prop || defaultValue  // This will use defaultValue for falsy values like 0 or ''
   ```
4. Use cases for optional chaining and nullish coalescing:
   - Accessing nested object properties
   - Calling methods that might not exist
   - Accessing array elements
   - Dealing with API responses
   - Working with optional parameters
   - Handling user input
5. When not to use:
   - When you're certain a value exists
   - When you want to throw an error for missing values
   - When dealing with required parameters in function signatures

## Hook Organization
1. Keep hooks colocated with their related components/pages
2. Name query hooks with verb prefix and Query suffix (e.g., useGetProjectsQuery)
3. Name mutation hooks with verb prefix and Mutation suffix (e.g., useCreateProjectMutation)
4. Keep prefixes in the following format:
    - Get
    - Create
    - Update
    - Delete
4. Keep hooks focused and single-responsibility
5. Place hooks in the same directory as their related component/page

## Styling Rules
1. Use Tailwind CSS for styling
2. Follow mobile-first approach
3. Use CSS variables for theming
4. Avoid inline styles
5. Use classnames package for conditional classes
6. CSS Class Naming Conventions:
   - Use `color-{name}` for text colors (e.g., `color-secondary-2`, `color-primary-1`)
   - Use `text-{name}` for text-related utilities (e.g., `text-p2`, `text-h4`)
   - Use `bg-{name}` for background colors
   - Use `border-{name}` for border colors
   - DO NOT change existing class names without explicit direction
   - DO NOT assume Tailwind conventions (like `text-{color}`) unless explicitly specified
7. Spacing Preferences:
   - **Prefer containers with `space-y-*` or `gap-y-*`** over individual `margin` classes for vertical spacing
   - **Prefer containers with `space-x-*` or `gap-x-*`** over individual `margin` classes for horizontal spacing
   - **Prefer `padding` over `margin`** in general for component spacing
   - Use `gap-*` for flexbox and grid layouts
   - Use `space-*` for flow layouts with multiple children
   - Examples:
     ```tsx
     // Good - container controls spacing
     <div className="space-y-4">
       <div>Item 1</div>
       <div>Item 2</div>
       <div>Item 3</div>
     </div>
     
     // Good - flexbox with gap
     <div className="flex flex-col gap-4">
       <div>Item 1</div>
       <div>Item 2</div>
     </div>
     
     // Good - padding for component spacing
     <div className="p-4 bg-white">Content</div>
     
     // Avoid - individual margins
     <div>
       <div className="mb-4">Item 1</div>
       <div className="mb-4">Item 2</div>
       <div>Item 3</div>
     </div>
     ```

8. **Component-Local CSS Organization**:
   - Create component-specific CSS files alongside components when needed
   - Organize components with custom CSS in folders with both the component and CSS file
   - Use an index.ts file to export both the component and import the CSS
   - Structure example:
     ```
     components/
       |- SearchResult/
          |- SearchResult.tsx      // Component implementation
          |- SearchResult.css      // Component-specific styles and animations
          |- index.ts              // Exports component and imports CSS
       |- SimpleComponent.tsx      // Simple components without custom CSS
     ```
   - Index file pattern:
     ```typescript
     import './SearchResult.css'
     export { SearchResult } from './SearchResult'
     ```
   - Keep keyframes, custom animations, and component-specific styles in local CSS files
   - Only use global CSS (index.css) for design system utilities and base styles
   - Benefits:
     - Better organization and maintainability
     - Easier to find and modify component-specific styles
     - Clear separation between global and component styles
     - Better tree-shaking and code splitting opportunities

## API Integration
1. All API configuration in config directory
2. Use typed API responses
3. Handle errors consistently
4. Use environment variables for endpoints
5. Implement proper error handling

## Alphabetization Rules

1. **Props:** When passing props to a component (JSX or function), list them in alphabetical order.
   ```tsx
   // Good
   <Button
     className="btn-primary"
     disabled={isDisabled}
     onClick={onClick}
     type="submit"
   />
   
   // Bad
   <Button
     onClick={onClick}
     type="submit"
     className="btn-primary"
     disabled={isDisabled}
   />
   ```
2. **Variables and State:** Declare variables, state hooks, and function parameters in alphabetical order when possible.
   ```tsx
   // Good
   const [activeWords, setActiveWords] = useState<string[]>([])
   const [selectedCollectionId, setSelectedCollectionId] = useState<string | null>(null)
   
   // Good (function params)
   function doSomething(activeWords, projectName, selectedCollectionId) { ... }
   ```
3. **className Values:** When using multiple Tailwind or CSS classes, list them alphabetically for consistency.
   ```tsx
   // Good
   <div className="bg-white p-4 rounded shadow" />
   
   // Bad
   <div className="shadow rounded p-4 bg-white" />
   ```

**Benefits:**
- Improves code readability and maintainability
- Reduces merge conflicts
- Makes code reviews easier

## Conditional Rendering
1. Prefer logical AND (`&&`) over ternary operators for simple conditionals
2. Use ternary operators only for:
   - Different values of the same prop
   - Non-JSX values
   - Complex inline conditions

### Examples

#### Simple Conditional (Preferred)
```jsx
{condition && <Component />}
{!condition && <AlternativeComponent />}
```

#### Multiple Conditions (Preferred)
```jsx
{conditionA && <ComponentA />}
{conditionB && <ComponentB />}
{!(conditionA || conditionB) && <FallbackComponent />}
```

#### Inline Conditions
```jsx
<div className={`base-class ${isActive && 'active-class'}`}>
  {text || 'Default text'}
</div>
```

### Guidelines
1. Keep conditional logic simple and readable
2. Avoid nested ternaries
3. Use logical operators for boolean conditions
4. Consider extracting complex conditions to variables
5. Document complex conditional logic

## Loading and Error State Handling
1. **Use Early Returns**: Handle loading and error states with early returns instead of ternary operators
2. **Keep UI Structure Consistent**: Maintain the same container structure in loading states when possible
3. **Clear State Hierarchy**: Handle states in order of priority: error → loading → empty → content

### Examples

#### Loading State (Preferred)
```jsx
export const MyComponent = ({ isLoading, error, data }) => {
  if (error) {
    return (
      <div className="container">
        <div className="error-message">Failed to load data</div>
      </div>
    )
  }

  if (isLoading) {
    return (
      <div className="container">
        <div className="loading-message">Loading...</div>
      </div>
    )
  }

  if (!data?.length) {
    return (
      <div className="container">
        <div className="empty-message">No data available</div>
      </div>
    )
  }

  return (
    <div className="container">
      {data.map(item => <Item key={item.id} {...item} />)}
    </div>
  )
}
```

#### Avoid Nested Ternaries (Bad)
```jsx
// Bad - hard to read and maintain
return (
  <div className="container">
    {error ? (
      <div>Error occurred</div>
    ) : isLoading ? (
      <div>Loading...</div>
    ) : data?.length ? (
      data.map(item => <Item key={item.id} {...item} />)
    ) : (
      <div>No data</div>
    )}
  </div>
)
```

### Benefits
- **Improved Readability**: Each state is clearly separated and easy to understand
- **Better Maintainability**: Easy to modify individual states without affecting others
- **Consistent Structure**: Maintains UI layout consistency across different states
- **Easier Testing**: Each state can be tested independently

## Export Patterns and Tree-Shaking

### Avoid Barrel Files
Do not create barrel files that re-export multiple components together. Barrel files typically look like this:

```typescript
// DO NOT DO THIS
export * from './Component1';
export * from './Component2';
export * from './Component3';
```

### Proper index.ts Export Pattern
Each component should be in its own file with a proper named export. The `index.ts` file should individually export components to ensure tree-shaking works correctly:

```typescript
// CORRECT APPROACH
export { Component1 } from './Component1';
export { Component2 } from './Component2';
export { Component3 } from './Component3';
```

### Benefits
1. **Better Tree-Shaking**: When using wildcard exports (`export *`), bundlers may struggle to properly tree-shake unused components
2. **Smaller Bundle Size**: Proper named exports allow bundlers to only include what's actually used
3. **Clear Component Dependencies**: Makes it easier to track which components are actually used in the application
4. **Faster Build Times**: More efficient compilation due to clearer dependency graph

### Example Component Structure
```
components/
  |- Button/
     |- Button.tsx       // Component implementation
     |- Button.test.tsx  // Component tests
     |- index.ts         // Exports just the Button component
  |- Card/
     |- Card.tsx         // Component implementation
     |- Card.test.tsx    // Component tests
     |- index.ts         // Exports just the Card component
  |- index.ts            // Exports individual components, not using wildcards
```

In the top-level `index.ts`:
```typescript
export { Button } from './Button';
export { Card } from './Card';
// Not using: export * from './Button';
```